import * as Request from "../Request";
import * as Response from "../Response";
import { Encapsulation } from "../exceptions";
import { Method } from "./httpMethods";
import * as Layer from "./Layer";
import * as Foxify from "..";
declare module Router {
    interface Middleware {
        path: string;
        handlers: Layer.Handler[];
    }
    interface Route {
        method: Method;
        path: string;
        opts: Layer.RouteOptions;
        handlers: Layer.Handler[];
        middlewares: Layer.Handler[];
    }
    interface Params {
        [param: string]: Layer.Handler;
    }
    type MethodFunction<T = Router> = (path: string, options: Layer.RouteOptions | Layer.Handler | Layer.Handler[], ...handlers: Array<Layer.Handler | Layer.Handler[]>) => T;
    type PathMethodFunction<T = Router> = (options: Layer.RouteOptions | Layer.Handler | Layer.Handler[], ...handlers: Array<Layer.Handler | Layer.Handler[]>) => T;
    interface MethodFunctions<T = Router> {
        get: Router.MethodFunction<T>;
        post: Router.MethodFunction<T>;
        put: Router.MethodFunction<T>;
        head: Router.MethodFunction<T>;
        delete: Router.MethodFunction<T>;
        options: Router.MethodFunction<T>;
        trace: Router.MethodFunction<T>;
        copy: Router.MethodFunction<T>;
        lock: Router.MethodFunction<T>;
        mkcol: Router.MethodFunction<T>;
        move: Router.MethodFunction<T>;
        purge: Router.MethodFunction<T>;
        propfind: Router.MethodFunction<T>;
        proppatch: Router.MethodFunction<T>;
        unlock: Router.MethodFunction<T>;
        report: Router.MethodFunction<T>;
        mkactivity: Router.MethodFunction<T>;
        checkout: Router.MethodFunction<T>;
        merge: Router.MethodFunction<T>;
        "m-search": Router.MethodFunction<T>;
        notify: Router.MethodFunction<T>;
        subscribe: Router.MethodFunction<T>;
        unsubscribe: Router.MethodFunction<T>;
        patch: Router.MethodFunction<T>;
        search: Router.MethodFunction<T>;
        connect: Router.MethodFunction<T>;
    }
    interface PathMethods<T = any> {
        get: Router.PathMethodFunction<T>;
        post: Router.PathMethodFunction<T>;
        put: Router.PathMethodFunction<T>;
        head: Router.PathMethodFunction<T>;
        delete: Router.PathMethodFunction<T>;
        options: Router.PathMethodFunction<T>;
        trace: Router.PathMethodFunction<T>;
        copy: Router.PathMethodFunction<T>;
        lock: Router.PathMethodFunction<T>;
        mkcol: Router.PathMethodFunction<T>;
        move: Router.PathMethodFunction<T>;
        purge: Router.PathMethodFunction<T>;
        propfind: Router.PathMethodFunction<T>;
        proppatch: Router.PathMethodFunction<T>;
        unlock: Router.PathMethodFunction<T>;
        report: Router.PathMethodFunction<T>;
        mkactivity: Router.PathMethodFunction<T>;
        checkout: Router.PathMethodFunction<T>;
        merge: Router.PathMethodFunction<T>;
        "m-search": Router.PathMethodFunction<T>;
        notify: Router.PathMethodFunction<T>;
        subscribe: Router.PathMethodFunction<T>;
        unsubscribe: Router.PathMethodFunction<T>;
        patch: Router.PathMethodFunction<T>;
        search: Router.PathMethodFunction<T>;
        connect: Router.PathMethodFunction<T>;
    }
}
interface Router extends Router.MethodFunctions {
}
declare class Router {
    prefix: string;
    static isRouter: (arg: any) => arg is Router;
    tree: Layer;
    middlewares: Router.Middleware[];
    routes: Router.Route[];
    params: Router.Params;
    caseSensitive: boolean;
    ignoreTrailingSlash: boolean;
    maxParamLength: number;
    allowUnsafeRegex: boolean;
    constructor(prefix?: string);
    protected _on(method: Method | Method[], path: string, opts: Layer.RouteOptions | undefined, handlers: Layer.Handler[]): this;
    protected _insert(method: Method, path: string, kind: number, options: Layer.RouteOptions | undefined, params: string[] | undefined, handlers: Layer.Handler[] | undefined, middlewares: Layer.Handler[] | undefined, regex: RegExp | null): this;
    protected _next: (req: Request, res: Response, handlers: Encapsulation[], index?: number) => void;
    protected _safeNext: Encapsulation;
    private _use;
    initialize(app: Foxify): this;
    on(method: Method | Method[], path: string, opts: Layer.RouteOptions | Layer.Handler | Layer.Handler[], ...handlers: Array<Layer.Handler | Layer.Handler[]>): this;
    route(path: string): Router.PathMethods<Router.PathMethods>;
    all(path: string, opts: Layer.RouteOptions | Layer.Handler | Layer.Handler[], ...handlers: Array<Layer.Handler | Layer.Handler[]>): this;
    use(path: string | Layer.Handler | Layer.Handler[] | Router | Router[], ...handlers: Array<Layer.Handler | Layer.Handler[] | Router | Router[]>): this;
    param(param: string, handler: Layer.Handler): this;
    reset(): this;
    lookup(req: Request, res: Response): void;
    find(method: Method, path: string): {
        handlers: Encapsulation[];
        options: Layer.RouteOptions;
        params: any;
    };
    prettyPrint(): string;
}
export = Router;
