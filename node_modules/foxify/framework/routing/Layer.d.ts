import { Method } from "./httpMethods";
import * as Request from "../Request";
import * as Response from "../Response";
import { Encapsulation } from "../exceptions";
declare module Layer {
    type Handler = (request: Request, response: Response, next: () => void) => void;
    interface HandlerObject {
        handlers: Encapsulation[];
        handlersLength: number;
        params: string[];
        paramsLength: number;
        options: RouteOptions;
        prettyPrint: boolean;
    }
    interface Handlers {
        [method: string]: HandlerObject;
        ACL: HandlerObject;
        BIND: HandlerObject;
        CHECKOUT: HandlerObject;
        CONNECT: HandlerObject;
        COPY: HandlerObject;
        DELETE: HandlerObject;
        GET: HandlerObject;
        HEAD: HandlerObject;
        LINK: HandlerObject;
        LOCK: HandlerObject;
        "M-SEARCH": HandlerObject;
        MERGE: HandlerObject;
        MKACTIVITY: HandlerObject;
        MKCALENDAR: HandlerObject;
        MKCOL: HandlerObject;
        MOVE: HandlerObject;
        NOTIFY: HandlerObject;
        OPTIONS: HandlerObject;
        PATCH: HandlerObject;
        POST: HandlerObject;
        PROPFIND: HandlerObject;
        PROPPATCH: HandlerObject;
        PURGE: HandlerObject;
        PUT: HandlerObject;
        REBIND: HandlerObject;
        REPORT: HandlerObject;
        SEARCH: HandlerObject;
        SOURCE: HandlerObject;
        SUBSCRIBE: HandlerObject;
        TRACE: HandlerObject;
        UNBIND: HandlerObject;
        UNLINK: HandlerObject;
        UNLOCK: HandlerObject;
        UNSUBSCRIBE: HandlerObject;
    }
    interface Options {
        ACL: RouteOptions;
        BIND: RouteOptions;
        CHECKOUT: RouteOptions;
        CONNECT: RouteOptions;
        COPY: RouteOptions;
        DELETE: RouteOptions;
        GET: RouteOptions;
        HEAD: RouteOptions;
        LINK: RouteOptions;
        LOCK: RouteOptions;
        "M-SEARCH": RouteOptions;
        MERGE: RouteOptions;
        MKACTIVITY: RouteOptions;
        MKCALENDAR: RouteOptions;
        MKCOL: RouteOptions;
        MOVE: RouteOptions;
        NOTIFY: RouteOptions;
        OPTIONS: RouteOptions;
        PATCH: RouteOptions;
        POST: RouteOptions;
        PROPFIND: RouteOptions;
        PROPPATCH: RouteOptions;
        PURGE: RouteOptions;
        PUT: RouteOptions;
        REBIND: RouteOptions;
        REPORT: RouteOptions;
        SEARCH: RouteOptions;
        SOURCE: RouteOptions;
        SUBSCRIBE: RouteOptions;
        TRACE: RouteOptions;
        UNBIND: RouteOptions;
        UNLINK: RouteOptions;
        UNLOCK: RouteOptions;
        UNSUBSCRIBE: RouteOptions;
    }
    interface Children {
        [label: string]: Layer | undefined;
    }
    type JsonSchemaType = "string" | "integer" | "number" | "array" | "object" | "boolean" | "null";
    interface JsonSchemaProperties {
        [property: string]: {
            type: JsonSchemaType;
            default?: any;
        };
    }
    interface JsonSchema {
        title?: string;
        type: JsonSchemaType;
        properties?: JsonSchemaProperties;
        patternProperties?: JsonSchemaProperties;
        additionalProperties?: {
            type: JsonSchemaType;
        };
        required?: string[];
    }
    interface Schema {
        response: {
            [statusCode: number]: JsonSchema;
        };
    }
    interface RouteOptions {
        schema: Schema;
    }
}
interface Layer {
}
declare class Layer {
    prefix: string;
    children: Layer.Children;
    kind: number;
    regex: RegExp | null;
    params: string[];
    static isLayer: (arg: any) => arg is Layer;
    static TYPES: {
        STATIC: 0;
        PARAM: 1;
        MATCH_ALL: 2;
        REGEX: 3;
        MULTI_PARAM: 4;
    };
    static Handlers: Function;
    handlers: Layer.Handlers;
    wildcardChild: Layer | null;
    parametricBrother: Layer | null;
    numberOfChildren: number;
    constructor(prefix?: string, children?: Layer.Children, kind?: number, regex?: RegExp | null, params?: string[], handlers?: Layer.Handlers);
    readonly label: string;
    addChild(layer: Layer): this;
    reset(prefix?: string): this;
    findByLabel(path: string): Layer | undefined;
    findChild(path: string, method: Method): Layer | null;
    addHandler(method: Method, options: Layer.RouteOptions | undefined, handlers: Layer.Handler[], prettyPrint?: boolean): this;
    getHandler(method: Method): Layer.HandlerObject;
    prettyPrint(prefix: string, tail?: boolean): string;
}
export = Layer;
