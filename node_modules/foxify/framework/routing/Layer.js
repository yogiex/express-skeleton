"use strict";
const assert = require("assert");
const httpMethods_1 = require("./httpMethods");
const exceptions_1 = require("../exceptions");
const OPTIONS = { schema: { response: {} } };
const buildHandlers = (handlers) => {
    let code = `handlers = handlers || {}
  `;
    for (let i = 0; i < httpMethods_1.default.length; i++) {
        const m = httpMethods_1.default[i];
        code += `this["${m}"] = handlers["${m}"] || {
      handlers: [],
      handlersLength: 0,
      params: [],
      paramsLength: 0,
      options: ${JSON.stringify(OPTIONS)},
      prettyPrint: false
    }
    `;
    }
    return new Function("handlers", code); // eslint-disable-line
};
const Handlers = buildHandlers();
const TYPES = {
    STATIC: 0,
    PARAM: 1,
    MATCH_ALL: 2,
    REGEX: 3,
    // It's used for a parameter, that is followed by another parameter in the same part
    MULTI_PARAM: 4,
};
class Layer {
    constructor(prefix = "/", children = {}, kind = TYPES.STATIC, regex = null, params = [], handlers) {
        this.prefix = prefix;
        this.children = children;
        this.kind = kind;
        this.regex = regex;
        this.params = params;
        this.wildcardChild = null;
        this.parametricBrother = null;
        this.numberOfChildren = Object.keys(this.children).length;
        this.handlers = new Handlers(handlers);
        const paramsLength = params.length;
        httpMethods_1.default.forEach((method) => {
            this.handlers[method].params = params;
            this.handlers[method].paramsLength = paramsLength;
        });
    }
    get label() {
        return this.prefix[0];
    }
    addChild(layer) {
        let label = "";
        switch (layer.kind) {
            case TYPES.STATIC:
                label = layer.label;
                break;
            case TYPES.PARAM:
            case TYPES.REGEX:
            case TYPES.MULTI_PARAM:
                label = ":";
                break;
            case TYPES.MATCH_ALL:
                this.wildcardChild = layer;
                label = "*";
                break;
            default:
                throw new Error(`Unknown layer kind: ${layer.kind}`);
        }
        assert(this.children[label] === undefined, `There is already a child with label "${label}"`);
        this.children[label] = layer;
        this.numberOfChildren++;
        const labels = Object.keys(this.children);
        let parametricBrother = null;
        for (let i = 0; i < labels.length; i++) {
            const child = this.children[labels[i]];
            if (child.label === ":") {
                parametricBrother = child;
                break;
            }
        }
        // Save the parametric brother inside a static children
        for (let i = 0; i < labels.length; i++) {
            const child = this.children[labels[i]];
            if (child.kind === TYPES.STATIC && parametricBrother)
                child.parametricBrother = parametricBrother;
        }
        return this;
    }
    reset(prefix = "/") {
        this.prefix = prefix;
        this.children = {};
        this.kind = TYPES.STATIC;
        this.handlers = new Handlers();
        this.regex = null;
        this.wildcardChild = null;
        this.numberOfChildren = 0;
        return this;
    }
    findByLabel(path) {
        return this.children[path[0]];
    }
    findChild(path, method) {
        let child = this.children[path[0]];
        if (child !== undefined && (child.numberOfChildren > 0 || child.handlers[method].handlersLength !== 0))
            if (path.slice(0, child.prefix.length) === child.prefix)
                return child;
        child = this.children[":"] || this.children["*"];
        if (child !== undefined && (child.numberOfChildren > 0 || child.handlers[method].handlersLength !== 0))
            return child;
        return null;
    }
    addHandler(method, options = OPTIONS, handlers, prettyPrint = false) {
        const length = handlers.length;
        if (length === 0)
            return this;
        this.handlers[method].handlers.push(...handlers.map((handler) => new exceptions_1.Encapsulation(handler)));
        this.handlers[method].handlersLength += length;
        this.handlers[method].options = Object.assign({}, OPTIONS, options, { schema: options.schema || { response: {} } });
        this.handlers[method].prettyPrint = this.handlers[method].prettyPrint || prettyPrint;
        return this;
    }
    getHandler(method) {
        return this.handlers[method];
    }
    prettyPrint(prefix, tail = false) {
        const handlers = this.handlers;
        const methods = Object.keys(handlers)
            .filter((method) => handlers[method].prettyPrint);
        let paramName = "";
        if (this.prefix === ":") {
            const params = this.params;
            const param = params[params.length - 1];
            methods.forEach((method, index) => {
                if (methods.length > 1) {
                    if (index === 0) {
                        paramName += `${param} (${method}`;
                        return;
                    }
                    paramName += `|${method}`;
                    paramName += (index === methods.length - 1 ? ")" : "");
                }
                else
                    paramName = `${param} (${method})`;
            });
        }
        else if (methods.length)
            paramName = ` (${methods.join("|")})`;
        let tree = `${prefix}${tail ? "└── " : "├── "}${this.prefix}${paramName}\n`;
        prefix = `${prefix}${tail ? "    " : "│   "}`;
        const labels = Object.keys(this.children);
        for (let i = 0; i < labels.length - 1; i++)
            tree += this.children[labels[i]].prettyPrint(prefix);
        if (labels.length > 0)
            tree += this.children[labels[labels.length - 1]].prettyPrint(prefix, true);
        return tree;
    }
}
Layer.isLayer = (arg) => arg instanceof Layer;
Layer.TYPES = TYPES;
Layer.Handlers = Handlers;
module.exports = Layer;
