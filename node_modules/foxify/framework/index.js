"use strict";
require("./bootstrap");
const os = require("os");
const serveStatic = require("serve-static");
const inject = require("@foxify/inject");
const qs = require("qs");
const constants = require("./constants");
const routing_1 = require("./routing");
const utils = require("./utils");
const Server = require("./Server");
const RequestClass = require("./Request");
const ResponseClass = require("./Response");
const events = require("./events");
const view_1 = require("./view");
const OPTIONS = ["https", "x-powered-by", "routing.case-sensitive", "routing.ignore-trailing-slash",
    "routing.allow-unsafe-regex", "json.escape"];
const SETTINGS = ["env", "url", "port", "workers", "https.cert", "https.key", "json.spaces",
    "json.replacer", "query.parser", "routing.max-param-length", "subdomain.offset"];
class Foxify {
    constructor() {
        this._options = {
            https: false,
            ["x-powered-by"]: true,
            routing: {
                "case-sensitive": true,
                "ignore-trailing-slash": false,
                "allow-unsafe-regex": false,
            },
            json: {
                escape: false,
            },
        };
        this._settings = {
            env: process.env.NODE_ENV || "production",
            url: process.env.APP_URL || "localhost",
            port: process.env.APP_PORT ? +process.env.APP_PORT : 3000,
            workers: process.env.WORKERS ? +process.env.WORKERS : os.cpus().length,
            subdomain: {
                offset: 2,
            },
            https: {
                cert: undefined,
                key: undefined,
            },
            json: {
                replacer: undefined,
                spaces: undefined,
            },
            query: {
                parser: undefined,
            },
            routing: {
                "max-param-length": 100,
            },
        };
        this._router = new routing_1.Router();
        /* apply http routing methods */
        ["route", "use", "all"].concat(routing_1.httpMethods).forEach((method) => {
            method = method.toLowerCase();
            if (this[method])
                return;
            this[method] = (...args) => {
                this._router[method](...args);
                return this;
            };
        });
    }
    /* handle options & settings */
    _set(setting, value, object) {
        const keys = setting.split(".");
        if (keys.length === 1)
            object[keys[0]] = value;
        else
            this._set(utils.array.tail(keys).join("."), value, object[keys[0]]);
    }
    /* handle options */
    enable(option) {
        if (!utils.string.isString(option))
            throw new TypeError("Argument 'option' should be an string");
        if (!utils.array.contains(OPTIONS, option))
            throw new TypeError(`Unknown option '${option}'`);
        this._set(option, true, this._options);
        return this;
    }
    disable(option) {
        if (!utils.string.isString(option))
            throw new TypeError("Argument 'option' should be an string");
        if (!utils.array.contains(OPTIONS, option))
            throw new TypeError(`Unknown option '${option}'`);
        this._set(option, false, this._options);
        return this;
    }
    enabled(option) {
        if (!utils.string.isString(option))
            throw new TypeError("Argument 'option' should be an string");
        if (!utils.array.contains(OPTIONS, option))
            throw new TypeError(`Unknown option '${option}'`);
        const keys = option.split(".");
        let _opt = this._options;
        keys.forEach((key) => {
            if (utils.boolean.isBoolean(_opt))
                throw new Error("Unknown option");
            _opt = _opt[key];
        });
        return _opt;
    }
    disabled(option) {
        return !this.enabled(option);
    }
    /* handle settings */
    set(setting, value) {
        if (!utils.string.isString(setting))
            throw new TypeError("Argument 'setting' should be an string");
        switch (setting) {
            case "env":
            case "url":
                if (!utils.string.isString(value))
                    throw new TypeError(`setting '${setting}' should be an string`);
                break;
            case "port":
            case "workers":
                if (!utils.number.isNumber(value))
                    throw new TypeError(`setting '${setting}' should be a number`);
                if (value < 1)
                    throw new TypeError(`setting '${setting}' should be a positive number`);
                break;
            case "https.cert":
                if (!utils.string.isString(value))
                    throw new TypeError(`setting '${setting}' should be an string`);
                break;
            case "https.key":
                if (!utils.string.isString(value))
                    throw new TypeError(`setting '${setting}' should be an string`);
                break;
            case "json.spaces":
            case "routing.max-param-length":
            case "subdomain.offset":
                if (value == null)
                    break;
                if (!utils.number.isNumber(value))
                    throw new TypeError(`setting '${setting}' should be a number`);
                if (value < 0)
                    throw new TypeError(`setting '${setting}' should be a positive number or zero`);
                break;
            case "json.replacer":
            case "query.parser":
                if (value == null)
                    break;
                if (!utils.function.isFunction(value))
                    throw new TypeError(`setting '${setting}' should be a function`);
                break;
            default:
                throw new TypeError(`Unknown setting '${setting}'`);
        }
        this._set(setting, value, this._settings);
        return this;
    }
    get(path, options, ...controllers) {
        if (!options) {
            const setting = path;
            if (!utils.string.isString(setting))
                throw new TypeError("'setting' should be an string");
            if (!utils.array.contains(SETTINGS, setting))
                throw new TypeError(`Unknown setting '${setting}'`);
            const keys = setting.split(".");
            let _setting = this._settings;
            keys.map((key) => {
                if (!utils.object.isObject(_setting))
                    throw new Error("Unknown setting");
                _setting = _setting[key];
            });
            return _setting;
        }
        return this.use(new routing_1.Router().get(path, options, ...controllers));
    }
    prettyPrint() {
        return this._router.prettyPrint();
    }
    /**
     * handle view
     * @param extension view template file extension
     * @param path the directory containing view templates
     */
    engine(extension, path, handler) {
        this._view = new view_1.Engine(path, extension, handler);
        return this;
    }
    inject(options, callback) {
        if (this.get("env") !== "test")
            throw new Error(`"inject" only works on testing environment`);
        this._router.initialize(this);
        if (typeof options === "string")
            options = { url: options };
        events.on("error", HttpException.handle);
        const opts = this._options;
        const settings = Object.assign({}, this._settings, { view: this._view });
        const IncomingMessage = RequestClass;
        IncomingMessage.prototype.settings = {
            subdomain: Object.assign({}, settings.subdomain),
        };
        if (Object.getOwnPropertyNames(IncomingMessage.prototype).indexOf("query") === -1) {
            const queryParse = settings.query.parser || qs.parse;
            Object.defineProperty(IncomingMessage.prototype, "query", {
                get() {
                    return queryParse(utils.parseUrl(this).query, { allowDots: true });
                },
            });
        }
        const ServerResponse = ResponseClass;
        ServerResponse.prototype.settings = {
            engine: settings.view,
            json: {
                escape: opts.json.escape,
                spaces: settings.json.spaces,
                replacer: settings.json.replacer,
            },
        };
        return inject(this._router.lookup.bind(this._router), Object.assign({}, options, { ServerResponse,
            IncomingMessage }), callback);
    }
    start(callback) {
        if (callback && !utils.function.isFunction(callback))
            throw new TypeError(`Expected 'callback' to be a function, got ${typeof callback} instead`);
        /* set node env */
        process.env.NODE_ENV = this.get("env");
        /* initialize the router with provided options and settings */
        this._router.initialize(this);
        const server = new Server(this._options, Object.assign({}, this._settings, { view: this._view }), this._router.lookup.bind(this._router));
        return server.start(callback);
    }
}
Foxify.constants = constants;
Foxify.Router = routing_1.Router;
Foxify.static = serveStatic;
Foxify.dotenv = (path) => {
    if (!utils.string.isString(path))
        throw new TypeError(`Expected 'dotenv' to be an string, got ${typeof path} instead`);
    require("dotenv").config({ path });
};
module.exports = Foxify;
