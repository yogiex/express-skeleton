"use strict";
/**
 * @leizm/web 中间件基础框架 - 内置模块
 * @author Zongmin Lei <leizongmin@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxyRequest = exports.parseProxyTarget = void 0;
const http_1 = require("http");
const https_1 = require("https");
const url_1 = require("url");
/**
 * 解析 URL
 *
 * @param url
 */
function parseProxyTarget(url) {
    const a = url_1.parse(url);
    return {
        protocol: (a.protocol || "http:"),
        port: a.port || (a.protocol === "https:" ? 443 : 80),
        hostname: a.hostname,
        path: a.path,
    };
}
exports.parseProxyTarget = parseProxyTarget;
/**
 * 代理 HTTP 请求
 *
 * @param req
 * @param res
 * @param target
 */
function proxyRequest(req, res, target) {
    return new Promise((resolve, reject) => {
        req.on("error", (err) => reject(err));
        res.on("error", (err) => reject(err));
        const formattedTarget = typeof target === "string" ? parseProxyTarget(target) : target;
        const remoteReq = (formattedTarget.protocol === "https:" ? https_1.request : http_1.request)({
            method: req.method,
            ...formattedTarget,
            headers: { ...formattedTarget.headers },
            timeout: formattedTarget.timeout,
        }, (remoteRes) => {
            remoteRes.on("error", (err) => reject(err));
            res.writeHead(remoteRes.statusCode || 200, remoteRes.headers);
            remoteRes.on("data", (chunk) => res.write(chunk));
            remoteRes.on("end", () => {
                res.end();
                resolve();
            });
        });
        remoteReq.on("error", (err) => reject(err));
        if (req.method === "GET" || req.method === "HEAD") {
            remoteReq.end();
        }
        else {
            req.pipe(remoteReq);
        }
    });
}
exports.proxyRequest = proxyRequest;
