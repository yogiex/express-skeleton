/**
 * @leizm/web 中间件基础框架
 * @author Zongmin Lei <leizongmin@gmail.com>
 */
/// <reference types="node" />
import { IncomingMessage, ServerResponse } from "http";
import { EventEmitter } from "events";
import { Request } from "./request";
import { Response } from "./response";
import { Application } from "./application";
import { RawRouteInfo, NextFunction, ErrorReason, RequestConstructor, ResponseConstructor, SYMBOL_CONNECT, SYMBOL_SESSION, SYMBOL_PUSH_NEXT_HANDLE, SYMBOL_POP_NEXT_HANDLE, SYMBOL_RAW_ROUTE_INFO } from "./define";
import { SessionInstance } from "./component/session";
import { ProxyTarget } from "./module/proxy.request";
export declare class Context<Q extends Request = Request, S extends Response = Response> extends EventEmitter {
    /** 原始ServerRequest对象 */
    protected _request?: Q;
    /** 原始ServerResponse对象 */
    protected _response?: S;
    /** 用于存储next函数的堆栈 */
    protected readonly nextHandleStack: NextFunction[];
    /** Request对象的构造函数 */
    protected requestConstructor: RequestConstructor;
    /** Response对象的构造函数 */
    protected responseConstructor: ResponseConstructor;
    /** 父 connect 实例 */
    [SYMBOL_CONNECT]: Application | undefined;
    /** 原始 Session对象 */
    [SYMBOL_SESSION]: SessionInstance;
    /** Session对象 */
    get session(): SessionInstance;
    /** 原始路由信息 */
    [SYMBOL_RAW_ROUTE_INFO]: RawRouteInfo | null;
    /** 其他可任意挂载在Context上的数据 */
    data: Record<string | number | symbol, any>;
    /**
     * 创建Request对象
     *
     * @param req 原始ServerRequest对象
     */
    protected createRequest(req: IncomingMessage): Q;
    /**
     * 创建Response对象
     *
     * @param res 原始ServerResponse对象
     */
    protected createResponse(res: ServerResponse): S;
    /**
     * 初始化
     *
     * @param req 原始ServerRequest对象
     * @param res 原始ServerResponse对象
     */
    init(req: IncomingMessage, res: ServerResponse): this;
    /**
     * 初始化完成，由 `Context.init()` 自动调用
     * 一般用于自定义扩展 Context 时，在此方法中加上自己的祝时候完成的代码
     */
    inited(): void;
    /**
     * 获得路由信息
     */
    get route(): RawRouteInfo;
    /**
     * 获取Request对象
     */
    get request(): Q;
    /**
     * 获取Response对象
     */
    get response(): S;
    /**
     * 转到下一个中间件
     *
     * @param err 出错信息
     */
    next(err?: ErrorReason): void;
    /**
     * next函数堆栈入栈
     *
     * @param next 回调函数
     */
    [SYMBOL_PUSH_NEXT_HANDLE](next: NextFunction): void;
    /**
     * next函数出栈
     */
    [SYMBOL_POP_NEXT_HANDLE](): NextFunction | void;
    /**
     * 注册中间件执行出错时的事件监听
     *
     * @param callback 回调函数
     */
    onError(callback: (err: ErrorReason) => void): void;
    /**
     * 注册响应结束时的事件监听
     *
     * @param callback 回调函数
     */
    onFinish(callback: () => void): void;
    /**
     * 注册准备输出响应头时的事件监听
     *
     * @param callback 回调函数
     */
    onWriteHead(callback: () => void): void;
    /**
     * 代理请求
     *
     * @param target
     */
    proxy(target: string | ProxyTarget): Promise<void>;
    /**
     * 代理请求
     *
     * @param url 目标地址
     * @param removeHeaderNames 需要删除的原始请求头列表
     */
    proxyWithHeaders(url: string, removeHeaderNames?: string[]): Promise<void>;
}
