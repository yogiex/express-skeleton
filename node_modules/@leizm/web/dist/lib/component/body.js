"use strict";
/**
 * @leizm/web 中间件基础框架 - 内置中间件
 * @author Zongmin Lei <leizongmin@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMultipart = exports.multipart = exports.raw = exports.urlencoded = exports.text = exports.json = exports.DEFAULT_MULTIPART_PARSER_OPTIONS = void 0;
const os = require("os");
const fs = require("fs");
const path = require("path");
const bodyParser = require("body-parser");
const utils_1 = require("../utils");
const Busboy = require("busboy");
const simple_random_1 = require("../module/simple.random");
exports.DEFAULT_MULTIPART_PARSER_OPTIONS = {
    fieldNameSize: 100,
    fieldSize: 1024 * 100,
    fields: Infinity,
    fileSize: Infinity,
    files: Infinity,
    parts: Infinity,
    headerPairs: 2000,
    smallFileSize: 0,
};
function json(options = {}) {
    const fn = bodyParser.json(options);
    return utils_1.fromClassicalHandle(fn);
}
exports.json = json;
function text(options = {}) {
    const fn = bodyParser.text(options);
    return utils_1.fromClassicalHandle(fn);
}
exports.text = text;
function urlencoded(options = {}) {
    const fn = bodyParser.urlencoded(options);
    return utils_1.fromClassicalHandle(fn);
}
exports.urlencoded = urlencoded;
function raw(options = {}) {
    const fn = bodyParser.raw(options);
    return utils_1.fromClassicalHandle(fn);
}
exports.raw = raw;
function multipart(options = {}) {
    return async function (ctx) {
        await parseMultipart(ctx, options);
        ctx.next();
    };
}
exports.multipart = multipart;
function parseMultipart(ctx, options = {}) {
    return new Promise((resolve, reject) => {
        const method = ctx.request.method;
        if (method === "GET" || method === "HEAD")
            return resolve();
        const contentType = ctx.request.headers["content-type"];
        if (!contentType)
            return resolve();
        if (contentType.indexOf("multipart/form-data") === -1)
            return resolve();
        const opts = { ...exports.DEFAULT_MULTIPART_PARSER_OPTIONS, ...options };
        const busboy = new Busboy({ headers: ctx.request.headers, limits: opts });
        const fields = {};
        const files = {};
        const asyncTasks = [];
        busboy.on("file", (fieldName, file, originalName, encoding, mimeType) => {
            asyncTasks.push(new Promise((resolve, reject) => {
                let buf = [];
                let size = 0;
                let fileStream = null;
                let filePath = "";
                file.on("data", (chunk) => {
                    size += chunk.length;
                    if (fileStream) {
                        fileStream.write(chunk);
                    }
                    else {
                        buf.push(chunk);
                        if (size > opts.smallFileSize) {
                            filePath = path.resolve(os.tmpdir(), `multipart-tmp-${simple_random_1.randomString(32)}`);
                            fileStream = fs.createWriteStream(filePath);
                            fileStream.on("error", (err) => reject(err));
                            fileStream.write(Buffer.concat(buf));
                            buf = [];
                        }
                    }
                });
                file.on("end", () => {
                    files[fieldName] = {
                        originalName: originalName || "",
                        encoding: encoding || "",
                        mimeType: mimeType || "",
                        size,
                    };
                    if (fileStream) {
                        fileStream.end(() => resolve());
                        files[fieldName].path = filePath;
                    }
                    else {
                        files[fieldName].buffer = Buffer.concat(buf);
                        resolve();
                    }
                });
            }));
        });
        busboy.on("field", (fieldName, val, fieldNameTruncated, valTruncated) => {
            fields[fieldName] = val;
        });
        busboy.on("finish", () => {
            Promise.all(asyncTasks)
                .then(() => {
                ctx.request.body = fields;
                ctx.request.files = files;
                resolve();
            })
                .catch(reject);
        });
        busboy.on("error", (err) => reject(err));
        ctx.request.req.pipe(busboy);
    });
}
exports.parseMultipart = parseMultipart;
