"use strict";
/**
 * @leizm/web 中间件基础框架
 * @author Zongmin Lei <leizongmin@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.colorRed = exports.notifyDeprecated = exports.execMiddlewareHandle = exports.wrapMiddlewareHandleWithMethod = exports.isMiddlewareErrorHandle = exports.fromClassicalErrorHandle = exports.toClassicalHandle = exports.fromClassicalHandle = exports.getRouteMatchPath = exports.getRouteParams = exports.testRoutePath = exports.parseRoutePath = exports.isPromise = void 0;
const path_to_regexp_1 = require("path-to-regexp");
const define_1 = require("./define");
const context_1 = require("./context");
const finalhandler_1 = require("./finalhandler");
/**
 * 判断是否为Promise对象
 *
 * @param p 要判断的对象
 */
function isPromise(p) {
    return p && typeof p.then === "function" && typeof p.catch === "function";
}
exports.isPromise = isPromise;
/**
 * 解析路由字符串
 *
 * @param route 路由字符串
 * @param options 选项
 */
function parseRoutePath(route, options) {
    if (route instanceof RegExp) {
        return { regexp: route, keys: [] };
    }
    const keys = [];
    const regexp = path_to_regexp_1.pathToRegexp(route, keys, options);
    return { regexp, keys };
}
exports.parseRoutePath = parseRoutePath;
/**
 * 判断路由规则是否匹配
 *
 * @param pathname 当前路径
 * @param route 当前路由规则
 */
function testRoutePath(pathname, route) {
    if (!route) {
        return true;
    }
    route.regexp.lastIndex = 0;
    return route.regexp.test(pathname);
}
exports.testRoutePath = testRoutePath;
/**
 * 获取当前匹配路由规则对应的URL参数
 *
 * @param pathname 当前路径
 * @param route 当前路由规则
 */
function getRouteParams(pathname, route) {
    const params = {};
    if (route) {
        route.regexp.lastIndex = 0;
        const values = route.regexp.exec(pathname);
        if (values && route.keys) {
            route.keys.forEach((k, i) => {
                params[k.name] = values[i + 1];
            });
        }
    }
    return params;
}
exports.getRouteParams = getRouteParams;
/**
 * 获取当前匹配路由规则对应的URL前缀
 *
 * @param pathname 当前路径
 * @param route 当前路由规则
 */
function getRouteMatchPath(pathname, route) {
    if (!route)
        return "";
    route.regexp.lastIndex = 0;
    const values = route.regexp.exec(pathname);
    return (values && values[0]) || "";
}
exports.getRouteMatchPath = getRouteMatchPath;
/**
 * 转换经典的connect中间件
 *
 * @param fn 处理函数
 */
function fromClassicalHandle(fn) {
    const handle = function (ctx) {
        let removedPath = "";
        if (handle.route) {
            removedPath = getRouteMatchPath(ctx.request.path, handle.route);
            if (removedPath) {
                ctx.request.url = ctx.request.url.slice(removedPath.length);
                ctx.request.path = ctx.request.path.slice(removedPath.length);
            }
        }
        fn(ctx.request.req, ctx.response.res, (err) => {
            if (removedPath) {
                ctx.request.url = removedPath + ctx.request.url;
                ctx.request.path = removedPath + ctx.request.path;
            }
            ctx.next(err);
        });
    };
    handle.classical = true;
    return handle;
}
exports.fromClassicalHandle = fromClassicalHandle;
/**
 * 转换为经典的connect中间件
 *
 * @param fn 处理函数
 */
function toClassicalHandle(fn, contextConstructor = context_1.Context) {
    return function (req, res, next) {
        const ctx = new contextConstructor().init(req, res);
        if (typeof next !== "function")
            next = finalhandler_1.default(req, res);
        ctx[define_1.SYMBOL_PUSH_NEXT_HANDLE](next);
        const ret = fn(ctx);
        if (isPromise(ret)) {
            ret.catch(next);
        }
    };
}
exports.toClassicalHandle = toClassicalHandle;
/**
 * 转换经典的connect错误处理中间件
 *
 * @param fn 处理函数
 */
function fromClassicalErrorHandle(fn) {
    const handle = function (ctx, err) {
        let removedPath = "";
        if (handle.route) {
            removedPath = getRouteMatchPath(ctx.request.path, handle.route);
            if (removedPath) {
                ctx.request.url = ctx.request.url.slice(removedPath.length);
                ctx.request.path = ctx.request.path.slice(removedPath.length);
            }
        }
        fn(err, ctx.request.req, ctx.response.res, (err) => {
            if (removedPath) {
                ctx.request.url = removedPath + ctx.request.url;
                ctx.request.path = removedPath + ctx.request.path;
            }
            ctx.next(err);
        });
    };
    handle.classical = true;
    return handle;
}
exports.fromClassicalErrorHandle = fromClassicalErrorHandle;
/**
 * 判断是否为错误处理中间件
 *
 * @param handle 处理函数
 */
function isMiddlewareErrorHandle(handle) {
    return handle.length > 1;
}
exports.isMiddlewareErrorHandle = isMiddlewareErrorHandle;
/**
 * 给当前中间件包装请求方法限制
 *
 * @param method 请求方法
 * @param handle 处理函数
 */
function wrapMiddlewareHandleWithMethod(method, handle) {
    function handleRequest(ctx, err) {
        if (ctx.request.method !== method)
            return ctx.next(err);
        execMiddlewareHandle(handle, ctx, err, (err2) => ctx.next(err2));
    }
    if (isMiddlewareErrorHandle(handle)) {
        return function (ctx, err) {
            handleRequest(ctx, err);
        };
    }
    return function (ctx) {
        handleRequest(ctx);
    };
}
exports.wrapMiddlewareHandleWithMethod = wrapMiddlewareHandleWithMethod;
/**
 * 执行中间件
 *
 * @param handle 处理函数
 * @param ctx 当前Context对象
 * @param err 出错信息
 * @param callback 回调函数
 */
function execMiddlewareHandle(handle, ctx, err, onError) {
    process.nextTick(function () {
        let p;
        try {
            p = handle(ctx, err);
        }
        catch (err) {
            return onError(err);
        }
        if (p && isPromise(p)) {
            p.catch(onError);
        }
    });
}
exports.execMiddlewareHandle = execMiddlewareHandle;
const notifiedDeprecatedMap = {};
/**
 * 提示接口更改
 * @param old 旧方法
 * @param current 新方法
 * @param since 开始完全弃用的版本
 */
function notifyDeprecated(old, current, since) {
    const msg = `[deprecated] @leizm/web模块：${old} 已更改为 ${current}，旧的使用方法将会在 v${since} 版本之后弃用，请及时更新您的代码。`;
    if (notifiedDeprecatedMap[msg]) {
        notifiedDeprecatedMap[msg]++;
    }
    else {
        notifiedDeprecatedMap[msg] = 1;
        console.error(colorRed(msg));
    }
}
exports.notifyDeprecated = notifyDeprecated;
/**
 * 返回红色ansi文本
 * @param str
 */
function colorRed(str) {
    return `\u001b[31m${str}\u001b[39m`;
}
exports.colorRed = colorRed;
